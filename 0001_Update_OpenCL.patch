From 2dbaba49cad86e83befae1f956af3f3b61f8cdce Mon Sep 17 00:00:00 2001
From: Khral Steelforge <garuda2550@gmail.com>
Date: Tue, 26 Feb 2019 16:10:19 +0700
Subject: opencl: Update to OpenCL 2.1.

Signed-off-by: Khral Steelforge <garuda2550@gmail.com>

diff --git a/dlls/opencl/opencl.c b/dlls/opencl/opencl.c
index 2d145bf25c..e316448eeb 100644
--- a/dlls/opencl/opencl.c
+++ b/dlls/opencl/opencl.c
@@ -64,6 +64,7 @@ cl_int WINAPI wine_clGetPlatformInfo(cl_platform_id platform, cl_platform_info p
     /* Hide all extensions.
      * TODO: Add individual extension support as needed.
      */
+/*
     if (param_name == CL_PLATFORM_EXTENSIONS)
     {
         ret = CL_INVALID_VALUE;
@@ -82,6 +83,7 @@ cl_int WINAPI wine_clGetPlatformInfo(cl_platform_id platform, cl_platform_info p
         }
     }
     else
+*/
     {
         ret = clGetPlatformInfo(platform, param_name, param_value_size, param_value, param_value_size_ret);
     }
@@ -113,6 +115,7 @@ cl_int WINAPI wine_clGetDeviceInfo(cl_device_id device, cl_device_info param_nam
     /* Hide all extensions.
      * TODO: Add individual extension support as needed.
      */
+/*
     if (param_name == CL_DEVICE_EXTENSIONS)
     {
         ret = CL_INVALID_VALUE;
@@ -131,6 +134,7 @@ cl_int WINAPI wine_clGetDeviceInfo(cl_device_id device, cl_device_info param_nam
         }
     }
     else
+*/
     {
         ret = clGetDeviceInfo(device, param_name, param_value_size, param_value, param_value_size_ret);
     }
@@ -146,6 +150,48 @@ cl_int WINAPI wine_clGetDeviceInfo(cl_device_id device, cl_device_info param_nam
     return ret;
 }
 
+cl_int WINAPI wine_clCreateSubDevices(cl_device_id in_device, const cl_device_partition_property * properties, cl_uint num_entries,
+                                      cl_device_id * out_devices, cl_uint * num_devices)
+{
+#ifdef CL_VERSION_1_2
+    cl_int ret;
+    TRACE("(%p, %p, %d, %p, %p)\n", in_device, properties, num_entries, out_devices, num_devices);
+    ret = clCreateSubDevices(in_device, properties, num_entries, out_devices, num_devices);
+    TRACE("(%p, %p, %d, %p, %p)=%d\n", in_device, properties, num_entries, out_devices, num_devices, ret);
+    return ret;
+#else
+    FIXME("stub\n");
+    return CL_SUCCESS;
+#endif
+}
+
+cl_int WINAPI wine_clRetainDevice(cl_device_id device)
+{
+#ifdef CL_VERSION_1_2
+    cl_int ret;
+    TRACE("(%p)\n", device);
+    ret = clRetainDevice(device);
+    TRACE("(%p)=%d\n", device, ret);
+    return ret;
+#else
+    FIXME("stub\n");
+    return CL_SUCCESS;
+#endif
+}
+
+cl_int WINAPI wine_clReleaseDevice(cl_device_id device)
+{
+#ifdef CL_VERSION_1_2
+    cl_int ret;
+    TRACE("(%p)\n", device);
+    ret = clReleaseDevice(device);
+    TRACE("(%p)=%d\n", device, ret);
+    return ret;
+#else
+    FIXME("stub\n");
+    return CL_SUCCESS;
+#endif
+}
 
 /*---------------------------------------------------------------*/
 /* Context APIs  */
@@ -276,13 +322,6 @@ cl_int WINAPI wine_clGetCommandQueueInfo(cl_command_queue command_queue, cl_comm
     return ret;
 }
 
-cl_int WINAPI wine_clSetCommandQueueProperty(cl_command_queue command_queue, cl_command_queue_properties properties, cl_bool enable,
-                                             cl_command_queue_properties * old_properties)
-{
-    FIXME("(%p, 0x%lx, %d, %p): deprecated\n", command_queue, (long unsigned int)properties, enable, old_properties);
-    return CL_INVALID_QUEUE_PROPERTIES;
-}
-
 
 /*---------------------------------------------------------------*/
 /* Memory Object APIs  */
@@ -295,6 +334,36 @@ cl_mem WINAPI wine_clCreateBuffer(cl_context context, cl_mem_flags flags, size_t
     return ret;
 }
 
+cl_mem WINAPI wine_clCreateImage(cl_context context, cl_mem_flags flags,
+                                 const cl_image_format * image_format, const cl_image_desc * image_desc, void * host_ptr, cl_int * errcode_ret)
+{
+#ifdef CL_VERSION_1_2
+    cl_mem ret;
+    TRACE("\n");
+    ret = clCreateImage(context, flags, image_format, image_desc, host_ptr, errcode_ret);
+    return ret;
+#else
+    FIXME("stub\n");
+    *errcode_ret = CL_SUCCESS;
+    return NULL;
+#endif
+}
+
+cl_mem WINAPI wine_clCreateSubBuffer(cl_mem buffer, cl_mem_flags flags,
+                                     cl_buffer_create_type buffer_create_type, const void * buffer_create_info, cl_int * errcode_ret)
+{
+#ifdef CL_VERSION_1_1
+    cl_mem ret;
+    TRACE("\n");
+    ret = clCreateSubBuffer(buffer, flags, buffer_create_type, buffer_create_info, errcode_ret);
+    return ret;
+#else
+    FIXME("stub\n");
+    *errcode_ret = CL_SUCCESS;
+    return NULL;
+#endif
+}
+
 cl_mem WINAPI wine_clCreateImage2D(cl_context context, cl_mem_flags flags, cl_image_format * image_format,
                                    size_t image_width, size_t image_height, size_t image_row_pitch, void * host_ptr, cl_int * errcode_ret)
 {
@@ -357,6 +426,49 @@ cl_int WINAPI wine_clGetImageInfo(cl_mem image, cl_image_info param_name, size_t
     return ret;
 }
 
+typedef struct
+{
+    void WINAPI (*pfn_notify)(cl_mem memobj, void* user_data);
+    void *user_data;
+} MEM_CALLBACK;
+
+static void mem_fn_notify(cl_mem memobj, void* user_data)
+{
+    MEM_CALLBACK *pcb;
+    FIXME("(%p, %p)\n", memobj, user_data);
+    pcb = (MEM_CALLBACK *) user_data;
+    if(pcb->pfn_notify) pcb->pfn_notify(memobj, pcb->user_data);
+    FIXME("Callback COMPLETED\n");
+}
+
+cl_int WINAPI wine_clSetMemObjectDestructorCallback(cl_mem memobj, void WINAPI(*pfn_notify)(cl_mem, void*), void *user_data)
+{
+#ifdef CL_VERSION_1_1
+    /* FIXME: I'm not sure about this. */
+    cl_int ret;
+    FIXME("(%p, %p, %p)\n", memobj, pfn_notify, user_data);
+    if(pfn_notify)
+    {
+        /* When pfn_notify is provided, clSetMemObjectDestructorCallback is asynchronous */
+        MEM_CALLBACK *pcb;
+        pcb = HeapAlloc(GetProcessHeap(), 0, sizeof(MEM_CALLBACK));
+        pcb->pfn_notify = pfn_notify;
+        pcb->user_data = user_data;
+        ret = clSetMemObjectDestructorCallback(memobj, mem_fn_notify, user_data);
+    }
+    else
+    {
+        /* When pfn_notify is NULL, clSetMemObjectDestructorCallback is synchronous */
+        ret = clSetMemObjectDestructorCallback(memobj, NULL, user_data);
+    }
+    FIXME("(%p, %p, %p)=%d\n", memobj, pfn_notify, user_data, ret);
+    return ret;
+#else
+    FIXME("stub\n");
+    return CL_SUCCESS;
+#endif
+}
+
 
 /*---------------------------------------------------------------*/
 /* Sampler APIs  */
@@ -418,6 +530,21 @@ cl_program WINAPI wine_clCreateProgramWithBinary(cl_context context, cl_uint num
     return ret;
 }
 
+cl_program WINAPI wine_clCreateProgramWithBuiltInKernels(cl_context context, cl_uint num_devices, const cl_device_id * device_list,
+                                                         const char * kernel_names, cl_int * errcode_ret)
+{
+#ifdef CL_VERSION_1_2
+    cl_program ret;
+    TRACE("\n");
+    ret = clCreateProgramWithBuiltInKernels(context, num_devices, device_list, kernel_names, errcode_ret);
+    return ret;
+#else
+    FIXME("stub\n");
+    *errcode_ret = CL_SUCCESS;
+    return NULL;
+#endif
+}
+
 cl_int WINAPI wine_clRetainProgram(cl_program program)
 {
     cl_int ret;
@@ -473,6 +600,65 @@ cl_int WINAPI wine_clBuildProgram(cl_program program, cl_uint num_devices, const
     return ret;
 }
 
+cl_int WINAPI wine_clCompileProgram(cl_program program, cl_uint num_devices, const cl_device_id * device_list, const char * options,
+                                    cl_uint num_input_headers, const cl_program * input_headers, const char ** header_include_names,
+                                    void WINAPI (*pfn_notify)(cl_program program, void * user_data),
+                                    void * user_data)
+{
+#ifdef CL_VERSION_1_2
+    cl_int ret;
+    TRACE("\n");
+    if(pfn_notify)
+    {
+        /* When pfn_notify is provided, clCompileProgram is asynchronous */
+        PROGRAM_CALLBACK *pcb;
+        pcb = HeapAlloc(GetProcessHeap(), 0, sizeof(PROGRAM_CALLBACK));
+        pcb->pfn_notify = pfn_notify;
+        pcb->user_data = user_data;
+        ret = clCompileProgram(program, num_devices, device_list, options, num_input_headers, input_headers, header_include_names, program_fn_notify, user_data);
+    }
+    else
+    {
+        /* When pfn_notify is NULL, clCompileProgram is synchronous */
+        ret = clCompileProgram(program, num_devices, device_list, options, num_input_headers, input_headers, header_include_names, NULL, user_data);
+    }
+    return ret;
+#else
+    FIXME("stub\n");
+    return CL_SUCCESS;
+#endif
+}
+
+cl_program WINAPI wine_clLinkProgram(cl_context context, cl_uint num_devices, const cl_device_id * device_list, const char * options,
+                                     cl_uint num_input_programs, const cl_program * input_programs,
+                                     void WINAPI (* pfn_notify)(cl_program program, void * user_data),
+                                     void * user_data, cl_int * errcode_ret)
+{
+#ifdef CL_VERSION_1_2
+    cl_program ret;
+    TRACE("\n");
+    if(pfn_notify)
+    {
+        /* When pfn_notify is provided, clLinkProgram is asynchronous */
+        PROGRAM_CALLBACK *pcb;
+        pcb = HeapAlloc(GetProcessHeap(), 0, sizeof(PROGRAM_CALLBACK));
+        pcb->pfn_notify = pfn_notify;
+        pcb->user_data = user_data;
+        ret = clLinkProgram(context, num_devices, device_list, options, num_input_programs, input_programs, program_fn_notify, user_data, errcode_ret);
+    }
+    else
+    {
+        /* When pfn_notify is NULL, clLinkProgram is synchronous */
+        ret = clLinkProgram(context, num_devices, device_list, options, num_input_programs, input_programs, NULL, user_data, errcode_ret);
+    }
+    return ret;
+#else
+    FIXME("stub\n");
+    *errcode_ret = CL_SUCCESS;
+    return NULL;
+#endif
+}
+
 cl_int WINAPI wine_clUnloadCompiler(void)
 {
     cl_int ret;
@@ -482,6 +668,20 @@ cl_int WINAPI wine_clUnloadCompiler(void)
     return ret;
 }
 
+cl_int WINAPI wine_clUnloadPlatformCompiler(cl_platform_id platform)
+{
+#ifdef CL_VERSION_1_2
+    cl_int ret;
+    TRACE("()\n");
+    ret = clUnloadPlatformCompiler(platform);
+    TRACE("()=%d\n", ret);
+    return ret;
+#else
+    FIXME("stub\n");
+    return CL_SUCCESS;
+#endif
+}
+
 cl_int WINAPI wine_clGetProgramInfo(cl_program program, cl_program_info param_name,
                                     size_t param_value_size, void * param_value, size_t * param_value_size_ret)
 {
@@ -555,6 +755,20 @@ cl_int WINAPI wine_clGetKernelInfo(cl_kernel kernel, cl_kernel_info param_name,
     return ret;
 }
 
+cl_int WINAPI wine_clGetKernelArgInfo(cl_kernel kernel, cl_uint arg_indx, cl_kernel_arg_info param_name,
+                                      size_t param_value_size, void * param_value, size_t * param_value_size_ret)
+{
+#ifdef CL_VERSION_1_2
+    cl_int ret;
+    TRACE("\n");
+    ret = clGetKernelArgInfo(kernel, arg_indx, param_name, param_value_size, param_value, param_value_size_ret);
+    return ret;
+#else
+    FIXME("stub\n");
+    return CL_SUCCESS;
+#endif
+}
+
 cl_int WINAPI wine_clGetKernelWorkGroupInfo(cl_kernel kernel, cl_device_id device,
                                             cl_kernel_work_group_info param_name, size_t param_value_size,
                                             void * param_value, size_t * param_value_size_ret)
@@ -586,6 +800,20 @@ cl_int WINAPI wine_clGetEventInfo(cl_event event, cl_event_info param_name, size
     return ret;
 }
 
+cl_event WINAPI wine_clCreateUserEvent(cl_context context, cl_int * errcode_ret)
+{
+#ifdef CL_VERSION_1_1
+    cl_event ret;
+    TRACE("\n");
+    ret = clCreateUserEvent(context, errcode_ret);
+    return ret;
+#else
+    FIXME("stub\n");
+    *errcode_ret = CL_SUCCESS;
+    return NULL;
+#endif
+}
+
 cl_int WINAPI wine_clRetainEvent(cl_event event)
 {
     cl_int ret;
@@ -602,6 +830,63 @@ cl_int WINAPI wine_clReleaseEvent(cl_event event)
     return ret;
 }
 
+cl_int WINAPI wine_clSetUserEventStatus(cl_event event, cl_int execution_status)
+{
+#ifdef CL_VERSION_1_1
+    cl_int ret;
+    TRACE("\n");
+    ret = clSetUserEventStatus(event, execution_status);
+    return ret;
+#else
+    FIXME("stub\n");
+    return CL_SUCCESS;
+#endif
+}
+
+typedef struct
+{
+    void WINAPI (*pfn_notify)(cl_event event, cl_int num, void* user_data);
+    void *user_data;
+} EVENT_CALLBACK;
+
+static void event_fn_notify(cl_event event, cl_int num, void* user_data)
+{
+    EVENT_CALLBACK *ecb;
+    FIXME("(%p, %d, %p)\n", event, num, user_data);
+    ecb = (EVENT_CALLBACK *) user_data;
+    if(ecb->pfn_notify) ecb->pfn_notify(event, num, ecb->user_data);
+    FIXME("Callback COMPLETED\n");
+}
+
+cl_int WINAPI wine_clSetEventCallback(cl_event event, cl_int command_exec_callback_type,
+                                      void WINAPI (*pfn_notify)(cl_event, cl_int, void *), void *user_data)
+{
+#ifdef CL_VERSION_1_1
+    /* FIXME: I'm not sure about this. */
+    cl_int ret;
+    FIXME("(%p, %d, %p, %p)\n", event, command_exec_callback_type, pfn_notify, user_data);
+    if(pfn_notify)
+    {
+        /* When pfn_notify is provided, clSetEventCallback is asynchronous */
+        EVENT_CALLBACK *ecb;
+        ecb = HeapAlloc(GetProcessHeap(), 0, sizeof(EVENT_CALLBACK));
+        ecb->pfn_notify = pfn_notify;
+        ecb->user_data = user_data;
+        ret = clSetEventCallback(event, command_exec_callback_type, event_fn_notify, user_data);
+    }
+    else
+    {
+        /* When pfn_notify is NULL, clSetEventCallback is synchronous */
+        ret = clSetEventCallback(event, command_exec_callback_type, NULL, user_data);
+    }
+    FIXME("(%p, %d, %p, %p)=%d\n", event, command_exec_callback_type, pfn_notify, user_data, ret);
+    return ret;
+#else
+    FIXME("stub\n");
+    return CL_SUCCESS;
+#endif
+}
+
 
 /*---------------------------------------------------------------*/
 /* Profiling APIs  */
@@ -651,6 +936,25 @@ cl_int WINAPI wine_clEnqueueReadBuffer(cl_command_queue command_queue, cl_mem bu
     return ret;
 }
 
+cl_int WINAPI wine_clEnqueueReadBufferRect(cl_command_queue command_queue, cl_mem buffer, cl_bool blocking_read,
+                                           const size_t * buffer_origin, const size_t * host_origin, const size_t * region,
+                                           size_t buffer_row_pitch, size_t buffer_slice_pitch, size_t host_row_pitch, size_t host_slice_pitch,
+                                           void * ptr, cl_uint num_events_in_wait_list, const cl_event * event_wait_list, cl_event * event)
+{
+#ifdef CL_VERSION_1_1
+    cl_int ret;
+    TRACE("\n");
+    ret = clEnqueueReadBufferRect(command_queue, buffer, blocking_read,
+        buffer_origin, host_origin, region,
+        buffer_row_pitch, buffer_slice_pitch, host_row_pitch, host_slice_pitch,
+        ptr, num_events_in_wait_list, event_wait_list, event);
+    return ret;
+#else
+    FIXME("stub\n");
+    return CL_SUCCESS;
+#endif
+}
+
 cl_int WINAPI wine_clEnqueueWriteBuffer(cl_command_queue command_queue, cl_mem buffer, cl_bool blocking_write,
                                         size_t offset, size_t cb, const void * ptr,
                                         cl_uint num_events_in_wait_list, const cl_event * event_wait_list, cl_event * event)
@@ -661,6 +965,39 @@ cl_int WINAPI wine_clEnqueueWriteBuffer(cl_command_queue command_queue, cl_mem b
     return ret;
 }
 
+cl_int WINAPI wine_clEnqueueWriteBufferRect( cl_command_queue command_queue, cl_mem buffer, cl_bool blocking_read,
+                                            const size_t * buffer_origin, const size_t * host_origin, const size_t * region,
+                                            size_t buffer_row_pitch, size_t buffer_slice_pitch, size_t host_row_pitch, size_t host_slice_pitch,
+                                            const void * ptr, cl_uint num_events_in_wait_list, const cl_event * event_wait_list, cl_event * event)
+{
+#ifdef CL_VERSION_1_1
+    cl_int ret;
+    TRACE("\n");
+    ret = clEnqueueWriteBufferRect(command_queue, buffer, blocking_read,
+        buffer_origin, host_origin, region,
+        buffer_row_pitch, buffer_slice_pitch, host_row_pitch, host_slice_pitch,
+        ptr, num_events_in_wait_list, event_wait_list, event);
+    return ret;
+#else
+    FIXME("stub\n");
+    return CL_SUCCESS;
+#endif
+}
+
+cl_int WINAPI wine_clEnqueueFillBuffer(cl_command_queue command_queue, cl_mem buffer, const void * pattern, size_t pattern_size, size_t offset, size_t cb,
+                                       cl_uint num_events_in_wait_list, const cl_event * event_wait_list, cl_event * event)
+{
+#ifdef CL_VERSION_1_2
+    cl_int ret;
+    TRACE("\n");
+    ret = clEnqueueFillBuffer(command_queue, buffer, pattern, pattern_size, offset, cb, num_events_in_wait_list, event_wait_list, event);
+    return ret;
+#else
+    FIXME("stub\n");
+    return CL_SUCCESS;
+#endif
+}
+
 cl_int WINAPI wine_clEnqueueCopyBuffer(cl_command_queue command_queue, cl_mem src_buffer, cl_mem dst_buffer,
                                        size_t src_offset, size_t dst_offset, size_t cb,
                                        cl_uint num_events_in_wait_list, const cl_event * event_wait_list, cl_event * event)
@@ -671,6 +1008,23 @@ cl_int WINAPI wine_clEnqueueCopyBuffer(cl_command_queue command_queue, cl_mem sr
     return ret;
 }
 
+cl_int WINAPI wine_clEnqueueCopyBufferRect(cl_command_queue command_queue, cl_mem src_buffer, cl_mem dst_buffer,
+                                           const size_t * src_origin, const size_t * dst_origin, const size_t * region,
+                                           size_t src_row_pitch, size_t src_slice_pitch,
+                                           size_t dst_row_pitch, size_t dst_slice_pitch,
+                                           cl_uint num_events_in_wait_list, const cl_event * event_wait_list, cl_event * event)
+{
+#ifdef CL_VERSION_1_1
+    cl_int ret;
+    TRACE("\n");
+    ret = clEnqueueCopyBufferRect(command_queue, src_buffer, dst_buffer, src_origin,  dst_origin, region, src_row_pitch, src_slice_pitch, dst_row_pitch, dst_slice_pitch, num_events_in_wait_list, event_wait_list, event);
+    return ret;
+#else
+    FIXME("stub\n");
+    return CL_SUCCESS;
+#endif
+}
+
 cl_int WINAPI wine_clEnqueueReadImage(cl_command_queue command_queue, cl_mem image, cl_bool blocking_read,
                                       const size_t * origin, const size_t * region,
                                       SIZE_T row_pitch, SIZE_T slice_pitch, void * ptr,
@@ -696,6 +1050,21 @@ cl_int WINAPI wine_clEnqueueWriteImage(cl_command_queue command_queue, cl_mem im
     return ret;
 }
 
+cl_int WINAPI wine_clEnqueueFillImage(cl_command_queue command_queue, cl_mem image, const void * fill_color,
+                                      const size_t * origin, const size_t * region,
+                                      cl_uint num_events_in_wait_list, const cl_event * event_wait_list, cl_event * event)
+{
+#ifdef CL_VERSION_1_2
+    cl_int ret;
+    TRACE("\n");
+    ret = clEnqueueFillImage(command_queue, image, fill_color,  origin, region, num_events_in_wait_list, event_wait_list, event);
+    return ret;
+#else
+    FIXME("stub\n");
+    return CL_SUCCESS;
+#endif
+}
+
 cl_int WINAPI wine_clEnqueueCopyImage(cl_command_queue command_queue, cl_mem src_image, cl_mem dst_image,
                                       size_t * src_origin, size_t * dst_origin, size_t * region,
                                       cl_uint num_events_in_wait_list, cl_event * event_wait_list, cl_event * event)
@@ -756,6 +1125,20 @@ cl_int WINAPI wine_clEnqueueUnmapMemObject(cl_command_queue command_queue, cl_me
     return ret;
 }
 
+cl_int WINAPI wine_clEnqueueMigrateMemObjects(cl_command_queue command_queue, cl_uint num_mem_objects, const cl_mem * mem_objects, cl_mem_migration_flags flags,
+                                              cl_uint num_events_in_wait_list, const cl_event * event_wait_list, cl_event * event)
+{
+#ifdef CL_VERSION_1_2
+    cl_int ret;
+    TRACE("\n");
+    ret = clEnqueueMigrateMemObjects(command_queue, num_mem_objects, mem_objects, flags, num_events_in_wait_list, event_wait_list, event);
+    return ret;
+#else
+    FIXME("stub\n");
+    return CL_SUCCESS;
+#endif
+}
+
 cl_int WINAPI wine_clEnqueueNDRangeKernel(cl_command_queue command_queue, cl_kernel kernel, cl_uint work_dim,
                                           size_t * global_work_offset, size_t * global_work_size, size_t * local_work_size,
                                           cl_uint num_events_in_wait_list, cl_event * event_wait_list, cl_event * event)
@@ -804,6 +1187,20 @@ cl_int WINAPI wine_clEnqueueMarker(cl_command_queue command_queue, cl_event * ev
     return ret;
 }
 
+cl_int WINAPI wine_clEnqueueMarkerWithWaitList(cl_command_queue command_queue, cl_uint num_events_in_wait_list,
+                                               const cl_event * event_wait_list, cl_event * event)
+{
+#ifdef CL_VERSION_1_2
+    cl_int ret;
+    TRACE("\n");
+    ret = clEnqueueMarkerWithWaitList(command_queue, num_events_in_wait_list, event_wait_list, event);
+    return ret;
+#else
+    FIXME("stub\n");
+    return CL_SUCCESS;
+#endif
+}
+
 cl_int WINAPI wine_clEnqueueWaitForEvents(cl_command_queue command_queue, cl_uint num_events, cl_event * event_list)
 {
     cl_int ret;
@@ -820,22 +1217,476 @@ cl_int WINAPI wine_clEnqueueBarrier(cl_command_queue command_queue)
     return ret;
 }
 
+cl_int WINAPI wine_clEnqueueBarrierWithWaitList(cl_command_queue command_queue, cl_uint num_events_in_wait_list,
+                                                const cl_event * event_wait_list, cl_event * event)
+{
+#ifdef CL_VERSION_1_2
+    cl_int ret;
+    TRACE("\n");
+    ret = clEnqueueBarrierWithWaitList(command_queue, num_events_in_wait_list, event_wait_list, event);
+    return ret;
+#else
+    FIXME("stub\n");
+    return CL_SUCCESS;
+#endif
+}
+
+
+/*---------------------------------------------------------------*/
+/* Deprecated APIs */
+
+cl_int WINAPI wine_clSetCommandQueueProperty(cl_command_queue command_queue, cl_command_queue_properties properties, cl_bool enable,
+                                             cl_command_queue_properties * old_properties)
+{
+    FIXME("(%p, 0x%lx, %d, %p): deprecated\n", command_queue, (long unsigned int) properties, enable, old_properties);
+    return CL_INVALID_QUEUE_PROPERTIES;
+}
+/*
+cl_int WINAPI wine_clCreateSubDevicesEXT(cl_device_id in_device, const cl_device_partition_property_ext * partition_properties,
+                                         cl_uint num_entries, cl_device_id * out_devices, cl_uint * num_devices)
+{
+    return clCreateSubDevicesEXT(in_device, partition_properties, num_entries, out_devices, num_devices);
+}
+
+cl_int WINAPI wine_clRetainDeviceEXT(cl_device_id device)
+{
+    return clRetainDeviceEXT(device);
+}
+
+cl_int WINAPI wine_clReleaseDeviceEXT(cl_device_id device)
+{
+    return clReleaseDeviceEXT(device);
+}
+*/
+
 
 /*---------------------------------------------------------------*/
 /* Extension function access */
 
-void * WINAPI wine_clGetExtensionFunctionAddress(const char * func_name)
+void * WINAPI wine_clGetExtensionFunctionAddressForPlatform(cl_platform_id platform, const char * function_name)
+{
+    void * ret = NULL;
+    FIXME("(%p, %s), extensions support is not implemented\n", platform, function_name);
+    /*ret = clGetExtensionFunctionAddressForPlatform(platform, function_name);
+    FIXME("(%p, %s)=%p\n", platform, function_name, ret);*/
+    return ret;
+}
+
+void * WINAPI wine_clGetExtensionFunctionAddress(const char * function_name)
+{
+    void * ret = NULL;
+    FIXME("(%s), extensions support is not implemented\n", function_name);
+    /*ret = clGetExtensionFunctionAddress(function_name);
+    FIXME("(%s)=%p\n", function_name, ret);*/
+    return ret;
+}
+
+
+/*---------------------------------------------------------------*/
+/* OpenCL 2.0 functions */
+
+cl_command_queue WINAPI wine_clCreateCommandQueueWithProperties(cl_context context, cl_device_id device,
+                                                           const cl_queue_properties * properties, cl_int * errcode_ret)
+{
+#ifdef CL_VERSION_2_0
+    cl_command_queue ret;
+    TRACE("(%p, %p, %p, %p)\n", context, device, properties, errcode_ret);
+    ret = clCreateCommandQueueWithProperties(context, device, properties, errcode_ret);
+    TRACE("(%p, %p, %p, %p)=%p\n", context, device, properties, errcode_ret, ret);
+    return ret;
+#else
+    FIXME("stub\n");
+    *errcode_ret = CL_SUCCESS;
+    return NULL;
+#endif
+}
+
+cl_mem WINAPI wine_clCreatePipe(cl_context context, cl_mem_flags flags,
+                                cl_uint pipe_packet_size, cl_uint pipe_max_packets,
+                                const cl_pipe_properties * properties, cl_int * errcode_ret)
+{
+#ifdef CL_VERSION_2_0
+    cl_mem ret;
+    TRACE("(%p, %lu, %d, %d, %p, %p)\n", context, flags, pipe_packet_size, pipe_max_packets, properties, errcode_ret);
+    ret = clCreatePipe(context, flags, pipe_packet_size, pipe_max_packets, properties, errcode_ret);
+    TRACE("(%p, %lu, %d, %d, %p, %p)=%p\n", context, flags, pipe_packet_size, pipe_max_packets, properties, errcode_ret, ret);
+    return ret;
+#else
+    FIXME("stub\n");
+    *errcode_ret = CL_SUCCESS;
+    return NULL;
+#endif
+}
+
+cl_int WINAPI wine_clGetPipeInfo(cl_mem pipe, cl_pipe_info param_name,
+                                 size_t param_value_size, void * param_value, size_t * param_value_size_ret)
+{
+#ifdef CL_VERSION_2_0
+    cl_int ret;
+    TRACE("(%p, %d, %lu, %p, %p)\n", pipe, param_name, param_value_size, param_value, param_value_size_ret);
+    ret = clGetPipeInfo(pipe, param_name, param_value_size, param_value, param_value_size_ret);
+    TRACE("(%p, %d, %lu, %p, %p)=%d\n", pipe, param_name, param_value_size, param_value, param_value_size_ret, ret);
+    return ret;
+#else
+    FIXME("stub\n");
+    return CL_SUCCESS;
+#endif
+}
+
+void * WINAPI wine_clSVMAlloc(cl_context context, cl_svm_mem_flags flags, size_t size, cl_uint alignment)
+{
+#ifdef CL_VERSION_2_0
+    void * ret = NULL;
+    TRACE("(%p, %lu, %lu, %u)\n", context, flags, size, alignment);
+    if (context)
+        ret = clSVMAlloc(context, flags, size, alignment);
+    TRACE("(%p, %lu, %lu, %u)=%p\n", context, flags, size, alignment, ret);
+    return ret;
+#else
+    FIXME("stub\n");
+    return NULL;
+#endif
+}
+
+void WINAPI wine_clSVMFree(cl_context context, void * svm_pointer)
+{
+#ifdef CL_VERSION_2_0
+    TRACE("(%p, %p)\n", context, svm_pointer);
+    if (!context || !svm_pointer)
+        return;
+    clSVMFree(context, svm_pointer);
+#else
+    FIXME("stub\n");
+#endif
+}
+
+typedef struct
+{
+    void WINAPI (*pfn_free_func)(cl_command_queue queue, cl_uint num_svm_pointers, void* svm_pointers[], void* user_data);
+    void *user_data;
+} SVM_CALLBACK;
+
+static void fn_free_func(cl_command_queue queue, cl_uint num_svm_pointers, void* svm_pointers[], void* user_data)
+{
+    SVM_CALLBACK *svmcb;
+    FIXME("(%p, %u, %p, %p)\n", queue, num_svm_pointers, svm_pointers, user_data);
+    svmcb = (SVM_CALLBACK *) user_data;
+    if(svmcb->pfn_free_func) svmcb->pfn_free_func(queue, num_svm_pointers, svm_pointers, svmcb->user_data);
+    FIXME("Callback COMPLETED\n");
+}
+
+cl_int WINAPI wine_clEnqueueSVMFree(cl_command_queue command_queue, cl_uint num_svm_pointers, void* svm_pointers[],
+                                    void WINAPI (*pfn_free_func)(cl_command_queue queue, cl_uint num_svm_pointers, void* svm_pointers[], void* user_data),
+                                    void* user_data, cl_uint num_events_in_wait_list, const cl_event* event_wait_list, cl_event* event)
+{
+#ifdef CL_VERSION_2_0
+    /* FIXME */
+    cl_int ret;
+    FIXME("(%p, %u, %p, %p, %p, %u, %p, %p)\n", command_queue, num_svm_pointers, svm_pointers, pfn_free_func, user_data, num_events_in_wait_list, event_wait_list, event);
+    if(pfn_free_func)
+    {
+        /* When pfn_free_func is provided, clEnqueueSVMFree is asynchronous */
+        SVM_CALLBACK *svmcb;
+        svmcb = HeapAlloc(GetProcessHeap(), 0, sizeof(SVM_CALLBACK));
+        svmcb->pfn_free_func = pfn_free_func;
+        svmcb->user_data = user_data;
+        ret = clEnqueueSVMFree(command_queue, num_svm_pointers, svm_pointers, fn_free_func, user_data,  num_events_in_wait_list, event_wait_list, event);
+    }
+    else
+    {
+        /* When pfn_free_func is NULL, clEnqueueSVMFree is synchronous */
+        ret = clEnqueueSVMFree(command_queue, num_svm_pointers, svm_pointers, NULL, user_data,  num_events_in_wait_list, event_wait_list, event);
+    }
+    FIXME("(%p, %u, %p, %p, %p, %u, %p, %p)=%d\n", command_queue, num_svm_pointers, svm_pointers, pfn_free_func, user_data, num_events_in_wait_list, event_wait_list, event, ret);
+    return ret;
+#else
+    FIXME("stub\n");
+    return CL_SUCCESS;
+#endif
+}
+
+cl_int WINAPI wine_clEnqueueSVMMemcpy( cl_command_queue command_queue, cl_bool blocking_copy,
+                                       void * dst_ptr, const void * src_ptr, size_t size,
+                                       cl_uint num_events_in_wait_list, const cl_event * event_wait_list, cl_event * event)
+{
+#ifdef CL_VERSION_2_0
+    cl_int ret;
+    TRACE("(%p, %d, %p, %p, %lu, %u, %p, %p)\n", command_queue, blocking_copy, dst_ptr, src_ptr, size, num_events_in_wait_list, event_wait_list, event);
+    ret = clEnqueueSVMMemcpy(command_queue, blocking_copy, dst_ptr, src_ptr, size, num_events_in_wait_list, event_wait_list, event);
+    TRACE("(%p, %d, %p, %p, %lu, %u, %p, %p)=%d\n", command_queue, blocking_copy, dst_ptr, src_ptr, size, num_events_in_wait_list, event_wait_list, event, ret);
+    return ret;
+#else
+    FIXME("stub\n");
+    return CL_SUCCESS;
+#endif
+}
+
+cl_int WINAPI wine_clEnqueueSVMMemFill(cl_command_queue command_queue,
+                    void * svm_ptr, const void * pattern, size_t pattern_size, size_t size,
+                    cl_uint num_events_in_wait_list, const cl_event * event_wait_list, cl_event * event)
+{
+#ifdef CL_VERSION_2_0
+    cl_int ret;
+    TRACE("(%p, %p, %p, %lu, %lu, %u %p, %p)\n", command_queue, svm_ptr, pattern, pattern_size, size, num_events_in_wait_list, event_wait_list, event);
+    ret = clEnqueueSVMMemFill(command_queue, svm_ptr, pattern, pattern_size, size, num_events_in_wait_list, event_wait_list, event);
+    TRACE("(%p, %p, %p, %lu, %lu, %u %p, %p)=%d\n", command_queue, svm_ptr, pattern, pattern_size, size, num_events_in_wait_list, event_wait_list, event, ret);
+    return ret;
+#else
+    FIXME("stub\n");
+    return CL_SUCCESS;
+#endif
+}
+
+cl_int WINAPI wine_clEnqueueSVMMap(cl_command_queue command_queue, cl_bool blocking_map, cl_map_flags flags,
+                                   void * svm_ptr, size_t size,
+                                   cl_uint num_events_in_wait_list, const cl_event * event_wait_list, cl_event * event)
+{
+#ifdef CL_VERSION_2_0
+    cl_int ret;
+    TRACE("(%p, %d, %lu, %p, %lu, %u %p, %p)\n", command_queue, blocking_map, flags, svm_ptr, size, num_events_in_wait_list, event_wait_list, event);
+    ret = clEnqueueSVMMap(command_queue, blocking_map, flags, svm_ptr, size, num_events_in_wait_list, event_wait_list, event);
+    TRACE("(%p, %d, %lu, %p, %lu, %u %p, %p)=%d\n", command_queue, blocking_map, flags, svm_ptr, size, num_events_in_wait_list, event_wait_list, event, ret);
+    return ret;
+#else
+    FIXME("stub\n");
+    return CL_SUCCESS;
+#endif
+}
+
+cl_int WINAPI wine_clEnqueueSVMUnmap(cl_command_queue command_queue, void * svm_ptr,
+                  cl_uint num_events_in_wait_list, const cl_event * event_wait_list, cl_event * event)
 {
-    void * ret = 0;
-    TRACE("(%s)\n",func_name);
+#ifdef CL_VERSION_2_0
+    cl_int ret;
+    TRACE("(%p, %p, %u, %p, %p)\n", command_queue, svm_ptr, num_events_in_wait_list, event_wait_list, event);
+    ret = clEnqueueSVMUnmap(command_queue, svm_ptr, num_events_in_wait_list, event_wait_list, event);
+    TRACE("(%p, %p, %u, %p, %p)=%d\n", command_queue, svm_ptr, num_events_in_wait_list, event_wait_list, event, ret);
+    return ret;
+#else
+    FIXME("stub\n");
+    return CL_SUCCESS;
+#endif
+}
+
+cl_sampler WINAPI wine_clCreateSamplerWithProperties(cl_context context, const cl_sampler_properties * sampler_properties, cl_int * errcode_ret)
+{
+#ifdef CL_VERSION_2_0
+    cl_sampler ret;
+    TRACE("(%p, %p, %p)\n", context, sampler_properties, errcode_ret);
+    ret = clCreateSamplerWithProperties(context, sampler_properties, errcode_ret);
+    TRACE("(%p, %p, %p)=%p\n", context, sampler_properties, errcode_ret, ret);
+    return ret;
+#else
+    FIXME("stub\n");
+    *errcode_ret = CL_SUCCESS;
+    return NULL;
+#endif
+}
+
+cl_int WINAPI wine_clSetKernelArgSVMPointer(cl_kernel kernel, cl_uint arg_index, const void * arg_value)
+{
+#ifdef CL_VERSION_2_0
+    cl_int ret;
+    TRACE("(%p, %u, %p)\n", kernel, arg_index, arg_value);
+    ret = clSetKernelArgSVMPointer(kernel, arg_index, arg_value);
+    TRACE("(%p, %u, %p)=%d\n", kernel, arg_index, arg_value, ret);
+    return ret;
+#else
+    FIXME("stub\n");
+    return CL_SUCCESS;
+#endif
+}
+
+cl_int WINAPI wine_clSetKernelExecInfo(cl_kernel kernel, cl_kernel_exec_info param_name, size_t param_value_size, const void * param_value)
+{
+#ifdef CL_VERSION_2_0
+    cl_int ret;
+    TRACE("(%p, %u, %lu, %p)\n", kernel, param_name, param_value_size, param_value);
+    ret = clSetKernelExecInfo(kernel, param_name, param_value_size, param_value);
+    TRACE("(%p, %u, %lu, %p)=%d\n", kernel, param_name, param_value_size, param_value, ret);
+    return ret;
+#else
+    FIXME("stub\n");
+    return CL_SUCCESS;
+#endif
+}
+/* FIXME:CL_EXT_SUFFIX__VERSION_2_0
+ * clGetKernelSubGroupInfo from OCL 2.1 as replacement?
+cl_int WINAPI wine_clGetKernelSubGroupInfoKHR(cl_kernel in_kernel, cl_device_id in_device, cl_kernel_sub_group_info param_name,
+                                              size_t input_value_size, const void * input_value,
+                                              size_t param_value_size, void * param_value, size_t * param_value_size_ret)
+{
+
+    return clGetKernelSubGroupInfoKHR(in_kernel, in_device, param_name,
+                                      input_value_size, input_value,
+                                      param_value_size, param_value, param_value_size_ret);
+}
+*/
+
+/*---------------------------------------------------------------*/
+/* OpenCL 2.1 functions */
+
+cl_int WINAPI wine_clSetDefaultDeviceCommandQueue(cl_context context, cl_device_id device, cl_command_queue command_queue)
+{
+#ifdef CL_VERSION_2_1
+    cl_int ret;
+    TRACE("(%p, %p, %p)\n", context, device, command_queue);
+    ret = clSetDefaultDeviceCommandQueue(context, device, command_queue);
+    TRACE("(%p, %p, %p)=%d\n", context, device, command_queue, ret);
+    return ret;
+#else
+    FIXME("stub\n");
+    return CL_SUCCESS;
+#endif
+}
+
+cl_program WINAPI wine_clCreateProgramWithIL(cl_context context, const void * il, size_t length, cl_int * errcode_ret)
+{
+#ifdef CL_VERSION_2_1
+    cl_program ret;
+    TRACE("(%p, %p, %lu, %p)\n", context, il, length, errcode_ret);
+    ret = clCreateProgramWithIL(context, il, length, errcode_ret);
+    TRACE("(%p, %p, %lu, %p)=%p\n", context, il, length, errcode_ret, ret);
+    return ret;
+#else
+    FIXME("stub\n");
+    *errcode_ret = CL_SUCCESS;
+    return NULL;
+#endif
+}
+
+cl_int WINAPI wine_clGetKernelSubGroupInfo(cl_kernel kernel, cl_device_id device, cl_kernel_sub_group_info param_name,
+                                           size_t input_value_size, const void * input_value,
+                                           size_t param_value_size, void * param_value, size_t * param_value_size_ret)
+{
+#ifdef CL_VERSION_2_1
+    cl_int ret;
+    TRACE("(%p, %p, %u, %lu, %p, %lu, %p, %p)\n",
+          kernel, device, param_name,
+          input_value_size, input_value,
+          param_value_size, param_value, param_value_size_ret);
+    ret = clGetKernelSubGroupInfo(kernel, device, param_name,
+                                  input_value_size, input_value,
+                                  param_value_size, param_value, param_value_size_ret);
+    TRACE("(%p, %p, %u, %lu, %p, %lu, %p, %p)=%d\n",
+          kernel, device, param_name,
+          input_value_size, input_value,
+          param_value_size, param_value, param_value_size_ret, ret);
+    return ret;
+#else
+    FIXME("stub\n");
+    return CL_SUCCESS;
+#endif
+}
+
+cl_kernel WINAPI wine_clCloneKernel(cl_kernel source_kernel, cl_int * errcode_ret)
+{
+#ifdef CL_VERSION_2_1
+    cl_kernel ret;
+    TRACE("(%p, %p)\n", source_kernel, errcode_ret);
+    ret = clCloneKernel(source_kernel, errcode_ret);
+    TRACE("(%p, %p)=%p\n", source_kernel, errcode_ret, ret);
+    return ret;
+#else
+    FIXME("stub\n");
+    *errcode_ret = CL_SUCCESS;
+    return NULL;
+#endif
+}
+
+cl_int WINAPI wine_clEnqueueSVMMigrateMem(cl_command_queue command_queue,
+                                          cl_uint num_svm_pointers, const void ** svm_pointers, const size_t * sizes, cl_mem_migration_flags flags,
+                                          cl_uint num_events_in_wait_list, const cl_event * event_wait_list, cl_event * event)
+{
+#ifdef CL_VERSION_2_1
+    cl_int ret;
+    TRACE("(%p, %u, %p, %p, %lu, %u, %p, %p)\n", command_queue, num_svm_pointers, svm_pointers, sizes, flags, num_events_in_wait_list, event_wait_list, event);
+    ret = clEnqueueSVMMigrateMem(command_queue,
+                                  num_svm_pointers, svm_pointers, sizes, flags,
+                                  num_events_in_wait_list, event_wait_list, event);
+    TRACE("(%p, %u, %p, %p, %lu, %u, %p, %p)=%d\n", command_queue, num_svm_pointers, svm_pointers, sizes, flags, num_events_in_wait_list, event_wait_list, event, ret);
+    return ret;
+#else
+    FIXME("stub\n");
+    return CL_SUCCESS;
+#endif
+}
+
+cl_int WINAPI wine_clGetDeviceAndHostTimer(cl_device_id device, cl_ulong * device_timestamp, cl_ulong * host_timestamp)
+{
+#ifdef CL_VERSION_2_1
+    cl_int ret;
+    TRACE("(%p, %p, %p)\n", device, device_timestamp, host_timestamp);
+    ret = clGetDeviceAndHostTimer(device, device_timestamp, host_timestamp);
+    TRACE("(%p, %p, %p)=%d\n", device, device_timestamp, host_timestamp, ret);
+    return ret;
+#else
+    FIXME("stub\n");
+    return CL_SUCCESS;
+#endif
+}
+
+cl_int WINAPI wine_clGetHostTimer(cl_device_id device, cl_ulong * host_timestamp)
+{
+#ifdef CL_VERSION_2_1
+    cl_int ret;
+    TRACE("(%p, %p)\n", device, host_timestamp);
+    ret = clGetHostTimer(device, host_timestamp);
+    TRACE("(%p, %p)=%d\n", device, host_timestamp, ret);
+    return ret;
+#else
+    FIXME("stub\n");
+    return CL_SUCCESS;
+#endif
+}
+
+
+/*---------------------------------------------------------------*/
+/* OpenCL 2.2 functions */
 #if 0
-    ret = clGetExtensionFunctionAddress(func_name);
+cl_int WINAPI wine_clSetProgramSpecializationConstant(cl_program program, cl_uint spec_id, size_t spec_size, const void* spec_value)
+{
+#ifdef CL_VERSION_2_2
+    cl_int ret;
+    TRACE("(%p, %u, %lu, %p)\n", program, spec_id, spec_size, spec_value);
+    ret = clSetProgramSpecializationConstant(program, spec_id, spec_size, spec_value);
+    TRACE("(%p, %u, %lu, %p)=%d\n", program, spec_id, spec_size, spec_value, ret);
+    return ret;
 #else
-    FIXME("extensions not implemented\n");
+    FIXME("stub\n");
+    return CL_SUCCESS;
 #endif
-    TRACE("(%s)=%p\n",func_name, ret);
+}
+
+cl_int WINAPI wine_clSetProgramReleaseCallback(cl_program program,
+                                               void WINAPI (*pfn_notify)(cl_program program, void * user_data),
+                                               void * user_data)
+{
+#ifdef CL_VERSION_2_2
+    cl_int ret;
+    FIXME("(%p, %p, %p)\n", program, pfn_notify, user_data);
+    if(pfn_notify)
+    {
+        /* When pfn_notify is provided, clBuildProgram is asynchronous */
+        PROGRAM_CALLBACK *pcb;
+        pcb = HeapAlloc(GetProcessHeap(), 0, sizeof(PROGRAM_CALLBACK));
+        pcb->pfn_notify = pfn_notify;
+        pcb->user_data = user_data;
+        ret = clSetProgramReleaseCallback(program, program_fn_notify, user_data);
+    }
+    else
+    {
+        / * When pfn_notify is NULL, clBuildProgram is synchronous * /
+        ret = clSetProgramReleaseCallback(program, NULL, user_data);
+    }
+    FIXME("(%p, %p, %p)=%d\n", program, pfn_notify, user_data, ret);
     return ret;
+#else
+    FIXME("stub\n");
+    return CL_SUCCESS;
+#endif
 }
+#endif
 
 
 #if OPENCL_WITH_GL
@@ -888,6 +1739,14 @@ cl_int WINAPI wine_clGetGLContextInfoKHR(const cl_context_properties * propertie
 {
 }
 
+
+/*---------------------------------------------------------------*/
+/* cl_khr_gl_event extension */
+
+cl_event WINAPI wine_clCreateEventFromGLsyncKHR(cl_context context, cl_GLsync sync, cl_int * errcode_ret)
+{
+}
+
 #endif
 
 
diff --git a/dlls/opencl/opencl.spec b/dlls/opencl/opencl.spec
index ba8ce6e7cd..1094e4b65c 100644
--- a/dlls/opencl/opencl.spec
+++ b/dlls/opencl/opencl.spec
@@ -94,3 +94,59 @@
 # @ stdcall clGetGLTextureInfo( long long long ptr ptr ) wine_clGetGLTextureInfo
 # @ stdcall clEnqueueAcquireGLObjects( long long ptr long ptr ptr ) wine_clEnqueueAcquireGLObjects
 # @ stdcall clEnqueueReleaseGLObjects( long long ptr long ptr ptr ) wine_clEnqueueReleaseGLObjects
+
+# OpenCL 1.1
+@ stdcall clCreateSubBuffer( long long long ptr ptr ) wine_clCreateSubBuffer
+@ stdcall clCreateUserEvent( long ptr ) wine_clCreateUserEvent
+@ stdcall clEnqueueCopyBufferRect( long long long ptr ptr ptr long long long long long ptr ptr ) wine_clEnqueueCopyBufferRect
+@ stdcall clEnqueueReadBufferRect( long long long ptr ptr ptr long long long long ptr long ptr ptr ) wine_clEnqueueReadBufferRect
+@ stdcall clEnqueueWriteBufferRect( long long long ptr ptr ptr long long long long ptr long ptr ptr ) wine_clEnqueueWriteBufferRect
+@ stdcall clSetEventCallback( long long ptr ptr ) wine_clSetEventCallback
+@ stdcall clSetMemObjectDestructorCallback( long ptr ptr ) wine_clSetMemObjectDestructorCallback
+@ stdcall clSetUserEventStatus( long long ) wine_clSetUserEventStatus
+
+# OpenCL 1.2
+@ stdcall clCompileProgram( long long ptr str long ptr ptr ptr ptr ) wine_clCompileProgram
+@ stub clCreateFromGLTexture
+@ stdcall clCreateImage( long long ptr ptr ptr ptr ) wine_clCreateImage
+@ stdcall clCreateProgramWithBuiltInKernels( long long ptr str ptr ) wine_clCreateProgramWithBuiltInKernels
+@ stdcall clCreateSubDevices( long ptr long ptr ptr ) wine_clCreateSubDevices
+@ stdcall clEnqueueBarrierWithWaitList( long long ptr ptr ) wine_clEnqueueBarrierWithWaitList
+@ stdcall clEnqueueFillBuffer( long long ptr long long long long ptr ptr ) wine_clEnqueueFillBuffer
+@ stdcall clEnqueueFillImage( long long ptr ptr ptr long ptr ptr ) wine_clEnqueueFillImage
+@ stdcall clEnqueueMarkerWithWaitList( long long ptr ptr ) wine_clEnqueueMarkerWithWaitList
+@ stdcall clEnqueueMigrateMemObjects( long long ptr long long ptr ptr ) wine_clEnqueueMigrateMemObjects
+@ stdcall clGetExtensionFunctionAddressForPlatform( long str ) wine_clGetExtensionFunctionAddressForPlatform
+@ stdcall clGetKernelArgInfo( long long long long ptr ptr ) wine_clGetKernelArgInfo
+@ stdcall clLinkProgram( long long ptr str long ptr ptr ptr ptr ) wine_clLinkProgram
+@ stdcall clReleaseDevice( long ) wine_clReleaseDevice
+@ stdcall clRetainDevice( long ) wine_clRetainDevice
+@ stdcall clUnloadPlatformCompiler( long ) wine_clUnloadPlatformCompiler
+
+# OpenCL 2.0
+@ stdcall clCreateCommandQueueWithProperties( long long ptr ptr ) wine_clCreateCommandQueueWithProperties
+@ stdcall clCreatePipe( long long long long ptr ptr ) wine_clCreatePipe
+@ stdcall clCreateSamplerWithProperties( long ptr ptr ) wine_clCreateSamplerWithProperties
+@ stdcall clEnqueueSVMFree( long long ptr ptr ptr long ptr ptr ) wine_clEnqueueSVMFree
+@ stdcall clEnqueueSVMMap( long long long ptr long long ptr ptr ) wine_clEnqueueSVMMap
+@ stdcall clEnqueueSVMMemcpy( long long ptr ptr long long ptr ptr ) wine_clEnqueueSVMMemcpy
+@ stdcall clEnqueueSVMMemFill( long ptr ptr long long long ptr ptr ) wine_clEnqueueSVMMemFill
+@ stdcall clEnqueueSVMUnmap( long ptr long ptr ptr ) wine_clEnqueueSVMUnmap
+@ stdcall clGetPipeInfo( long long long ptr ptr ) wine_clGetPipeInfo
+@ stdcall clSetKernelArgSVMPointer( long long long ptr ) wine_clSetKernelArgSVMPointer
+@ stdcall clSetKernelExecInfo( long long long ptr ) wine_clSetKernelExecInfo
+@ stdcall clSVMAlloc( long long long long ) wine_clSVMAlloc
+@ stdcall clSVMFree( long ptr ) wine_clSVMFree
+
+# OpenCL 2.1
+@ stdcall clCloneKernel( long ptr ) wine_clCloneKernel
+@ stdcall clCreateProgramWithIL( long ptr long ptr ) wine_clCreateProgramWithIL
+@ stdcall clEnqueueSVMMigrateMem( long long ptr ptr ptr long ptr ptr ) wine_clEnqueueSVMMigrateMem
+@ stdcall clGetDeviceAndHostTimer( long ptr ptr ) wine_clGetDeviceAndHostTimer
+@ stdcall clGetHostTimer( long ptr ) wine_clGetHostTimer
+@ stdcall clGetKernelSubGroupInfo( long long long long ptr long ptr ptr ) wine_clGetKernelSubGroupInfo
+@ stdcall clSetDefaultDeviceCommandQueue( long ptr ptr ) wine_clSetDefaultDeviceCommandQueue
+
+# OpenCL 2.2
+#@ stdcall clSetProgramReleaseCallback( long ptr ptr ) wine_clSetProgramReleaseCallback
+#@ stdcall clSetProgramSpecializationConstant( long long long ptr ) wine_clSetProgramSpecializationConstant
